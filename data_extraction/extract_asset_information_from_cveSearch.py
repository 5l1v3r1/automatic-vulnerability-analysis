"""
This file is to transfer retrieved .json file into local dictionary in .Pickle format.
And then extract information (CVE-ID, publish time, CWE, threat patterns, CVSS, etc,.) from the dictionary.
"""

import re
import csv
import json
import config
import pickle
from pprint import pprint

#Transfer retrieved .json file into local dictionary in .Pickle format.
def generate_asset_vulnerability_dict(asset_name):
    asset_vulnerability_dict = dict()
    file_name = asset_name +'_compiled_information.json'
    with open(config.asset_vulnerability_information_path + file_name, 'r') as f:
        asset_vulnerability_dict = json.loads(f.read())
    f.close()
    # Save dictionary in a LOCAL Json file !
    with open("../data/asset_vulnerability_dict_July/" + asset_name + "_vulnerability_dict_2019July.Pickle", "wb") as myFile:
        pickle.dump(asset_vulnerability_dict, myFile)
    return(asset_vulnerability_dict)


#Extract CVE-ID of retrieved vulnerability instances.
def extra_asset_cve_id(asset_name):
    asset_cve_id_list = []
    file_name = asset_name +"_vulnerability_dict_2019July.Pickle"
    with open("../data/asset_vulnerability_dict_July/" + file_name, "rb") as myFile:
        asset_vulnerability_dict = pickle.load(myFile)
        asset_item = asset_name + '_item'
        print("\ncvedetails_dict: " + str(asset_vulnerability_dict[asset_item][0]['id']))
        for item in asset_vulnerability_dict[asset_item]:
            asset_cve_id_list.append(item['id'])
        pprint(asset_cve_id_list)
        print(len(asset_cve_id_list))
    file = asset_name + "_cve_id"
    with open("../data/asset_vulnerability_dict_July/cveID_2019July/" + file +'.py', 'w') as f_write:
        f_write.write(asset_name + '_cve_id_list = ' + str(asset_cve_id_list))


#Extract publish time of retrieved vulnerability instances.
def extra_asset_cve_publish_time(asset_name):
    asset_cve_publish_time_list = []
    file_name = asset_name +"_vulnerability_dict_2019July.Pickle"
    with open("../data/asset_vulnerability_dict_July/" + file_name, "rb") as myFile:
        asset_vulnerability_dict = pickle.load(myFile)
        asset_item = asset_name + '_item'
        print("\ncvedetails_dict: " + str(asset_vulnerability_dict[asset_item][0]['Published']))
        for item in asset_vulnerability_dict[asset_item]:
            asset_cve_publish_time_list.append(item['Published'])
        pprint(asset_cve_publish_time_list)
    file = asset_name + "_cve_publish_time"
    with open("../data/asset_vulnerability_dict_July/publishtime_2019July/" + file +'.py', 'w') as f_write:
        f_write.write(asset_name + '_cve_publish_time_list = ' + str(asset_cve_publish_time_list))


#Extract publish time as well as vendor information of retrieved vulnerability instances.
def extra_asset_publishtime_vendor(asset_name):
    asset_cve_publish_time_vendor_list = []
    file_name = asset_name +"_vulnerability_dict_2019July.Pickle"
    with open("../data/asset_vulnerability_dict_July/" + file_name, "rb") as myFile:
        asset_vulnerability_dict = pickle.load(myFile)
        asset_item = asset_name + '_item'
        for item in asset_vulnerability_dict[asset_item]:
            publish_time = item['Published']
            cvss = item['cvss']
            id = item['id']
            config = item['vulnerable_configuration']
            if config:
                for info in config:
                    text_split = [x.strip() for x in re.compile(r"(?<!\\)*:").split(info[8:])]
                    company = text_split[1]
                    publish_time_vendor = publish_time +':' + str(cvss) + ':' + company+':' + str(id)
                    if publish_time_vendor not in asset_cve_publish_time_vendor_list:
                        asset_cve_publish_time_vendor_list.append(publish_time_vendor)

    pprint(asset_cve_publish_time_vendor_list)
    pprint(len(asset_cve_publish_time_vendor_list))

    file5 = asset_name + "_publishtime_vendor"
    with open("../data/asset_vulnerability_dict_July/publishtime_vendor_2019July/" + file5 +'.py', 'w') as f_write:
        f_write.write(asset_name + '_publishtime_vendor_list = ' + str(asset_cve_publish_time_vendor_list))


#Extract vulnerable version of retrieved vulnerability instances.
def extra_asset_vulnerable_component_version(asset_name):
    global vendor_product
    file_name = asset_name +"_vulnerability_dict_2019July.Pickle"
    component_version_list = []
    vendor_product_list = []
    asset_cpe_list = []
    component_list = []
    component_type_list = []
    with open("../data/asset_vulnerability_dict_July/" + file_name, "rb") as myFile:
        asset_vulnerability_dict = pickle.load(myFile)
        asset_item = asset_name + '_item'
        #print("\nvulnerable_configuration: " + str(asset_vulnerability_dict[asset_item][0]['vulnerable_configuration']))
        for item in asset_vulnerability_dict[asset_item]:

            for list in item['vulnerable_configuration']:
                asset_cpe_list.append(list)

        try:
            for cpe_text in asset_cpe_list:
                component_type,company,component,version = get_information_from_cpe(cpe_text)

                component_information = component_type + ': ' + component
                if component_information not in component_list:
                    component_list.append(component_information)
                component_version = component_type + ': ' + component + ': ' + version
                if component_version not in component_version_list:
                    component_version_list.append(component_version)
                    vendor_product = company + ': ' + component
                if vendor_product not in vendor_product_list:
                    vendor_product_list.append(vendor_product)

        except IndexError:
            pass

        pprint(asset_cpe_list)
        pprint(len(asset_cpe_list))
        pprint(component_list)
        pprint(len(component_list))
        pprint(component_version_list)
        pprint(len(component_version_list))
        pprint(vendor_product_list)
        pprint(len(vendor_product_list))

    file1 = asset_name + "_vulnerable_component_version"
    with open("../data/asset_vulnerability_dict_July/vulnerable_version_2019July/" + file1 +'.py', 'w') as f_write:
        f_write.write(asset_name + '_vulnerable_component_version_list = ' + str(component_version_list))

    file2 = asset_name + "_vendor_product"
    with open("../data/asset_vulnerability_dict_July/vendor_product_2019July/" + file2 +'.py', 'w') as f_write:
        f_write.write(asset_name + '_vendor_product_list = ' + str(vendor_product_list))

    file3 = asset_name + "_cpe_list"
    with open("../data/asset_vulnerability_dict_July/cpe_dict_2019July/" + file3 +'.py', 'w') as f_write:
        f_write.write(asset_name + '_cpe_list = ' + str(asset_cpe_list))

    file4 = asset_name + "_vulnerable_component"
    with open("../data/asset_vulnerability_dict_July/vulnerable_component_2019July/" + file4 +'.py', 'w') as f_write:
        f_write.write(asset_name + '_vulnerable_component_list = ' + str(component_list))


#Correlate retrieved vulnerability instances against CPE.
def get_information_from_cpe(cpe_text):
    text_split = [x.strip() for x in re.compile(r"(?<!\\)*:").split(cpe_text[8:])]
    type_value = text_split[0]
    component_type = ''
    if type_value == 'a':
        component_type = 'software application'
    elif type_value == 'o':
        component_type = 'operating system'
    elif type_value == 'h':
        component_type = 'hardware device'
    else:
        print('ERROR! component type is: ', type_value)
    company = text_split[1]
    component = text_split[2]
    if len(text_split) > 3:
        version = text_split[3]
    else:
        version = 'n/a'
    return(component_type,company,component,version)


#Generate a
def generate_asset_threat_csv(asset_name):
    global vulnerability_type
    file_name = asset_name +'_July_compiled_information.json'
    #file_name = asset_name +'_cvss_reevaluate.json'
    with open(config.asset_vulnerability_information_path + file_name, 'r') as f:
        asset_vulnerability_dict = json.loads(f.read())
    f.close()
    file = asset_name + "_vulnerability_threat_information.csv"
    #file = asset_name + "_vulnerability_cvss_threat_information.csv"
    with open('../data/asset_vulnerability_dict_July/' + file, 'w', newline='') as f_output:
        csv_output = csv.writer(f_output)
        #csv_output.writerow(['ID', 'Attack_Vector', 'CVSS_Two_Base_Score','CVSS_Three_Base_Score','CVSS_Three_Tem_Score','CVSS_Three_Env_Score', 'CWE','Vulnerability_Type', 'Threat_Type'])
        csv_output.writerow(['ID', 'Attack_Vector', 'CVSS_Two_Base_Score', 'CWE','Vulnerability_Type', 'Threat_Type'])
        asset_item = asset_name + '_item'
        for item in asset_vulnerability_dict[asset_item]:
            id = item['id']
            if 'access' in item:
                attack_vector = item['access']['vector']
            else:
                attack_vector = 'n/a'
            cvss_two_base_score = item['cvss']
            #cvss_three_base_score = item['cvss-ba']
            #cvss_three_tem_score = item['cvss-te']
            #cvss_three_env_score = item['cvss-en']
            cwe_id = ''
            if 'cwe' in item:
                cwe_id = item['cwe']
                vulnerability_type = get_cwe_information_from_csv(cwe_id)
            elif 'cwe' not in item:
                cwe_id = 'n/a'
                vulnerability_type = 'n/a'
            threat_type = get_threat_information_from_cveDetails(item['id'])
            csv_output.writerow([id, attack_vector, cvss_two_base_score, cwe_id, vulnerability_type, threat_type])
            #csv_output.writerow([id, attack_vector, cvss_two_base_score, cvss_three_base_score, cvss_three_tem_score, cvss_three_env_score, cwe_id, vulnerability_type, threat_type])


#Correlate retrieved vulnerability instances against CWE.
def get_cwe_information_from_csv(cwe_id):
    vulnerability_type = ''
    id = cwe_id[4:]
    csv_file = csv.reader(open( '../data/cwe_dict/sources/' + 'research_concept_cwe_dict.csv', "r"))
    for row in csv_file:
        if id == row[0]:
            print(row)
            vulnerability_type = row[1]
    return vulnerability_type


#Correlate retrieved vulnerability instances against CVEDetails.
def get_threat_information_from_cveDetails(cve_id):
    threat_type = []
    name_cat = ['memc', 'bypass', 'csrf', 'dirtra', 'dos', 'execution', 'fileinc', 'gainpre', 'httprs', 'infor', 'overflow',
            'sqli', 'xss']
    threat = ['Memory Corruption', 'Bypass Something', 'Cross-Site Request Forgery',
              'Directory Traversal', 'Denial of Service', 'Execute Code', 'File Inclusion', 'Gain Privilege',
              'Http Response Splitting', 'Gain Information', 'Overflow', 'Sql Injection', 'Cross Site Scripting']
    for cat_idx in range(13):
        fobj = open('../data/cvedetails_dict/cvedetails_dict' + name_cat[cat_idx], 'r')
        text = fobj.read().strip().split()
        try:
            s = cve_id
            if s == "":
                continue
            if s in text:
                threat_type.append(threat[cat_idx])

        except Exception as e:
            print(e)
    return threat_type



if __name__ == '__main__':
    generate_asset_vulnerability_dict("rtu")
    extra_asset_cve_id("rtu")
    extra_asset_vulnerable_component_version("rtu")
    extra_asset_publishtime_vendor("rtu")
    generate_asset_threat_csv("rtu")
    extra_asset_cve_publish_time("rtu")

